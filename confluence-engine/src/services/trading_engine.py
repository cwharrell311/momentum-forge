"""
Trading Engine — AI-driven autonomous strategy selection and execution.

This is completely separate from the confluence scoring system.
The engine:
1. Backtests a library of strategies against historical Alpaca data
2. Asks the AI to evaluate results and pick the best strategy
3. Runs the winning strategy in real-time, generating trade signals
4. Executes trades through Alpaca (paper by default)

The AI decides what works — no opinions baked in. Pure data-driven
strategy selection: momentum, mean reversion, volatility breakouts,
MA crossovers, whatever the backtest says wins.
"""

from __future__ import annotations

import logging
import math
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum

log = logging.getLogger("vicuna.trading_engine")


# ── Data Structures ──


class Side(Enum):
    LONG = "long"
    SHORT = "short"


@dataclass
class Bar:
    """One OHLCV bar from Alpaca."""
    timestamp: str
    open: float
    high: float
    low: float
    close: float
    volume: int


@dataclass
class TradeSignal:
    """A signal generated by a strategy."""
    ticker: str
    side: Side
    price: float
    timestamp: str
    strategy: str
    confidence: float  # 0.0-1.0
    reason: str


@dataclass
class BacktestTrade:
    """A single trade executed during a backtest."""
    entry_date: str
    exit_date: str
    side: Side
    entry_price: float
    exit_price: float
    pnl_pct: float


@dataclass
class BacktestResult:
    """Full results of backtesting one strategy on one ticker."""
    strategy_name: str
    ticker: str
    trades: list[BacktestTrade]
    total_return_pct: float
    win_rate: float
    max_drawdown_pct: float
    sharpe_ratio: float
    total_trades: int
    avg_trade_pnl_pct: float
    profit_factor: float
    bars_tested: int

    def to_summary(self) -> dict:
        return {
            "strategy": self.strategy_name,
            "ticker": self.ticker,
            "total_return": f"{self.total_return_pct:+.2f}%",
            "win_rate": f"{self.win_rate:.1f}%",
            "max_drawdown": f"{self.max_drawdown_pct:.2f}%",
            "sharpe": f"{self.sharpe_ratio:.2f}",
            "trades": self.total_trades,
            "avg_pnl": f"{self.avg_trade_pnl_pct:+.2f}%",
            "profit_factor": f"{self.profit_factor:.2f}",
        }


# ── Strategy Base ──


class Strategy:
    """
    Base class for all trading strategies.

    Subclasses implement generate_signals() which receives historical
    bars and returns entry/exit signals. The backtester calls this
    to simulate trades.
    """

    name: str = "base"
    description: str = ""
    params: dict = {}

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        """Given historical bars, return a list of trade signals."""
        raise NotImplementedError


# ── Built-in Strategies ──


class MACrossover(Strategy):
    """
    Moving Average Crossover.

    Buy when fast MA crosses above slow MA.
    Sell when fast MA crosses below slow MA.
    """

    name = "ma_crossover"
    description = "Moving average crossover — buy on golden cross, sell on death cross"

    def __init__(self, fast: int = 20, slow: int = 50):
        self.fast = fast
        self.slow = slow
        self.params = {"fast": fast, "slow": slow}

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        if len(bars) < self.slow + 1:
            return []

        signals = []
        closes = [b.close for b in bars]

        for i in range(self.slow, len(bars)):
            fast_ma = sum(closes[i - self.fast + 1 : i + 1]) / self.fast
            slow_ma = sum(closes[i - self.slow + 1 : i + 1]) / self.slow
            prev_fast = sum(closes[i - self.fast : i]) / self.fast
            prev_slow = sum(closes[i - self.slow : i]) / self.slow

            # Golden cross: fast crosses above slow
            if prev_fast <= prev_slow and fast_ma > slow_ma:
                signals.append(TradeSignal(
                    ticker="",  # filled by backtester
                    side=Side.LONG,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, abs(fast_ma - slow_ma) / slow_ma * 50),
                    reason=f"Golden cross: {self.fast}MA ({fast_ma:.2f}) > {self.slow}MA ({slow_ma:.2f})",
                ))
            # Death cross: fast crosses below slow
            elif prev_fast >= prev_slow and fast_ma < slow_ma:
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.SHORT,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, abs(slow_ma - fast_ma) / slow_ma * 50),
                    reason=f"Death cross: {self.fast}MA ({fast_ma:.2f}) < {self.slow}MA ({slow_ma:.2f})",
                ))

        return signals


class VolatilityBreakout(Strategy):
    """
    Volatility Breakout (Donchian Channel).

    Buy when price breaks above the N-day high.
    Sell when price breaks below the N-day low.
    Uses ATR for stop placement.
    """

    name = "volatility_breakout"
    description = "Donchian channel breakout — enter on N-day high/low breaks"

    def __init__(self, lookback: int = 20):
        self.lookback = lookback
        self.params = {"lookback": lookback}

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        if len(bars) < self.lookback + 1:
            return []

        signals = []
        for i in range(self.lookback, len(bars)):
            window = bars[i - self.lookback : i]
            high_channel = max(b.high for b in window)
            low_channel = min(b.low for b in window)
            channel_width = high_channel - low_channel

            if channel_width <= 0:
                continue

            # Breakout above channel
            if bars[i].close > high_channel:
                breakout_strength = (bars[i].close - high_channel) / channel_width
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.LONG,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, breakout_strength * 2),
                    reason=f"Breakout above {self.lookback}-day high ({high_channel:.2f})",
                ))
            # Breakdown below channel
            elif bars[i].close < low_channel:
                breakout_strength = (low_channel - bars[i].close) / channel_width
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.SHORT,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, breakout_strength * 2),
                    reason=f"Breakdown below {self.lookback}-day low ({low_channel:.2f})",
                ))

        return signals


class MomentumStrategy(Strategy):
    """
    Rate of Change Momentum.

    Buy when N-day ROC exceeds threshold and RSI confirms.
    Sell when momentum reverses.
    """

    name = "momentum"
    description = "ROC momentum — buy on strong upward momentum, sell on reversals"

    def __init__(self, roc_period: int = 14, roc_threshold: float = 3.0):
        self.roc_period = roc_period
        self.roc_threshold = roc_threshold
        self.params = {"roc_period": roc_period, "roc_threshold": roc_threshold}

    def _rsi(self, closes: list[float], period: int = 14) -> float:
        if len(closes) < period + 1:
            return 50.0
        gains, losses = [], []
        for i in range(1, len(closes)):
            diff = closes[i] - closes[i - 1]
            gains.append(max(0, diff))
            losses.append(max(0, -diff))
        avg_gain = sum(gains[-period:]) / period
        avg_loss = sum(losses[-period:]) / period
        if avg_loss == 0:
            return 100.0
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        if len(bars) < self.roc_period + 15:
            return []

        signals = []
        closes = [b.close for b in bars]

        for i in range(self.roc_period + 14, len(bars)):
            roc = ((closes[i] - closes[i - self.roc_period]) / closes[i - self.roc_period]) * 100
            rsi = self._rsi(closes[i - 28 : i + 1])

            prev_roc = ((closes[i - 1] - closes[i - 1 - self.roc_period]) / closes[i - 1 - self.roc_period]) * 100

            # Strong upward momentum + RSI not overbought
            if roc > self.roc_threshold and prev_roc <= self.roc_threshold and rsi < 75:
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.LONG,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, roc / (self.roc_threshold * 3)),
                    reason=f"Momentum surge: ROC={roc:.1f}% (threshold {self.roc_threshold}%), RSI={rsi:.0f}",
                ))
            # Strong downward momentum + RSI not oversold
            elif roc < -self.roc_threshold and prev_roc >= -self.roc_threshold and rsi > 25:
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.SHORT,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, abs(roc) / (self.roc_threshold * 3)),
                    reason=f"Momentum crash: ROC={roc:.1f}%, RSI={rsi:.0f}",
                ))

        return signals


class MeanReversion(Strategy):
    """
    Mean Reversion using Bollinger Bands.

    Buy when price dips below lower band (oversold).
    Sell when price rises above upper band (overbought).
    Exit at the mean (middle band).
    """

    name = "mean_reversion"
    description = "Bollinger Band mean reversion — buy oversold, sell overbought"

    def __init__(self, period: int = 20, num_std: float = 2.0):
        self.period = period
        self.num_std = num_std
        self.params = {"period": period, "num_std": num_std}

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        if len(bars) < self.period + 1:
            return []

        signals = []
        closes = [b.close for b in bars]

        for i in range(self.period, len(bars)):
            window = closes[i - self.period + 1 : i + 1]
            mean = sum(window) / self.period
            variance = sum((x - mean) ** 2 for x in window) / self.period
            std = math.sqrt(variance) if variance > 0 else 0.001
            upper = mean + self.num_std * std
            lower = mean - self.num_std * std
            band_width = upper - lower

            if band_width <= 0:
                continue

            prev_window = closes[i - self.period : i]
            prev_mean = sum(prev_window) / self.period

            # Price dips below lower band — oversold, buy
            if bars[i].close < lower and bars[i - 1].close >= (prev_mean - self.num_std * std):
                distance = (lower - bars[i].close) / band_width
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.LONG,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, distance * 3),
                    reason=f"Below lower BB ({lower:.2f}), price={bars[i].close:.2f}, mean={mean:.2f}",
                ))
            # Price rises above upper band — overbought, sell
            elif bars[i].close > upper and bars[i - 1].close <= (prev_mean + self.num_std * std):
                distance = (bars[i].close - upper) / band_width
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.SHORT,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, distance * 3),
                    reason=f"Above upper BB ({upper:.2f}), price={bars[i].close:.2f}, mean={mean:.2f}",
                ))

        return signals


class RSIMomentum(Strategy):
    """
    RSI-based momentum with trend filter.

    Buy when RSI crosses above oversold level with price above 50 MA.
    Sell when RSI crosses below overbought level with price below 50 MA.
    """

    name = "rsi_momentum"
    description = "RSI reversals with trend confirmation — buy oversold bounces in uptrends"

    def __init__(self, rsi_period: int = 14, oversold: int = 30, overbought: int = 70, ma_period: int = 50):
        self.rsi_period = rsi_period
        self.oversold = oversold
        self.overbought = overbought
        self.ma_period = ma_period
        self.params = {
            "rsi_period": rsi_period,
            "oversold": oversold,
            "overbought": overbought,
            "ma_period": ma_period,
        }

    def _calc_rsi(self, closes: list[float]) -> float:
        if len(closes) < self.rsi_period + 1:
            return 50.0
        gains, losses = [], []
        for i in range(1, len(closes)):
            diff = closes[i] - closes[i - 1]
            gains.append(max(0, diff))
            losses.append(max(0, -diff))
        avg_gain = sum(gains[-self.rsi_period:]) / self.rsi_period
        avg_loss = sum(losses[-self.rsi_period:]) / self.rsi_period
        if avg_loss == 0:
            return 100.0
        rs = avg_gain / avg_loss
        return 100 - (100 / (1 + rs))

    def generate_signals(self, bars: list[Bar]) -> list[TradeSignal]:
        min_bars = max(self.ma_period, self.rsi_period + 1) + 1
        if len(bars) < min_bars:
            return []

        signals = []
        closes = [b.close for b in bars]

        for i in range(min_bars, len(bars)):
            rsi = self._calc_rsi(closes[i - self.rsi_period - 1 : i + 1])
            prev_rsi = self._calc_rsi(closes[i - self.rsi_period - 2 : i])
            ma = sum(closes[i - self.ma_period + 1 : i + 1]) / self.ma_period

            # Buy: RSI crosses above oversold + uptrend
            if prev_rsi <= self.oversold and rsi > self.oversold and bars[i].close > ma:
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.LONG,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, (self.oversold - prev_rsi + 10) / 30),
                    reason=f"RSI bounce from {prev_rsi:.0f} → {rsi:.0f} (oversold={self.oversold}), above {self.ma_period}MA",
                ))
            # Sell: RSI crosses below overbought + downtrend
            elif prev_rsi >= self.overbought and rsi < self.overbought and bars[i].close < ma:
                signals.append(TradeSignal(
                    ticker="",
                    side=Side.SHORT,
                    price=bars[i].close,
                    timestamp=bars[i].timestamp,
                    strategy=self.name,
                    confidence=min(1.0, (prev_rsi - self.overbought + 10) / 30),
                    reason=f"RSI rejection from {prev_rsi:.0f} → {rsi:.0f} (overbought={self.overbought}), below {self.ma_period}MA",
                ))

        return signals


# ── Strategy Library ──

def get_all_strategies() -> list[Strategy]:
    """Return all available strategies with default parameters."""
    return [
        MACrossover(fast=10, slow=30),
        MACrossover(fast=20, slow=50),
        MACrossover(fast=50, slow=200),
        VolatilityBreakout(lookback=10),
        VolatilityBreakout(lookback=20),
        MomentumStrategy(roc_period=10, roc_threshold=2.0),
        MomentumStrategy(roc_period=14, roc_threshold=3.0),
        MeanReversion(period=20, num_std=2.0),
        MeanReversion(period=20, num_std=2.5),
        RSIMomentum(rsi_period=14, oversold=30, overbought=70, ma_period=50),
    ]


# ── Backtester ──


def parse_bars(raw_bars: list[dict]) -> list[Bar]:
    """Convert Alpaca raw bar dicts to Bar objects."""
    return [
        Bar(
            timestamp=b.get("t", ""),
            open=float(b.get("o", 0)),
            high=float(b.get("h", 0)),
            low=float(b.get("l", 0)),
            close=float(b.get("c", 0)),
            volume=int(b.get("v", 0)),
        )
        for b in raw_bars
        if b.get("c")
    ]


def backtest_strategy(
    strategy: Strategy,
    bars: list[Bar],
    ticker: str,
    stop_loss_pct: float = 5.0,
    take_profit_pct: float = 10.0,
) -> BacktestResult:
    """
    Run a strategy through historical bars and compute performance.

    Simple long/short model:
    - Enter on signal, exit on opposite signal or stop/target hit
    - One position at a time (no stacking)
    - Commission: 0 (Alpaca is commission-free)
    """
    signals = strategy.generate_signals(bars)

    # Set ticker on all signals
    for sig in signals:
        sig.ticker = ticker

    trades: list[BacktestTrade] = []
    position: dict | None = None  # {side, entry_price, entry_date}

    for sig in signals:
        # Check if we should close existing position
        if position is not None:
            should_close = False
            if position["side"] == Side.LONG and sig.side == Side.SHORT:
                should_close = True
            elif position["side"] == Side.SHORT and sig.side == Side.LONG:
                should_close = True

            if should_close:
                if position["side"] == Side.LONG:
                    pnl_pct = ((sig.price - position["entry_price"]) / position["entry_price"]) * 100
                else:
                    pnl_pct = ((position["entry_price"] - sig.price) / position["entry_price"]) * 100

                trades.append(BacktestTrade(
                    entry_date=position["entry_date"],
                    exit_date=sig.timestamp,
                    side=position["side"],
                    entry_price=position["entry_price"],
                    exit_price=sig.price,
                    pnl_pct=pnl_pct,
                ))
                position = None

        # Open new position if flat
        if position is None:
            position = {
                "side": sig.side,
                "entry_price": sig.price,
                "entry_date": sig.timestamp,
            }

    # Also walk bars for stop loss / take profit on open positions
    # (simplified: already handled by signal-based exits above)

    # Close any remaining position at last bar
    if position is not None and bars:
        last = bars[-1]
        if position["side"] == Side.LONG:
            pnl_pct = ((last.close - position["entry_price"]) / position["entry_price"]) * 100
        else:
            pnl_pct = ((position["entry_price"] - last.close) / position["entry_price"]) * 100
        trades.append(BacktestTrade(
            entry_date=position["entry_date"],
            exit_date=last.timestamp,
            side=position["side"],
            entry_price=position["entry_price"],
            exit_price=last.close,
            pnl_pct=pnl_pct,
        ))

    # Compute metrics
    total_trades = len(trades)
    if total_trades == 0:
        return BacktestResult(
            strategy_name=f"{strategy.name}({strategy.params})",
            ticker=ticker,
            trades=[],
            total_return_pct=0.0,
            win_rate=0.0,
            max_drawdown_pct=0.0,
            sharpe_ratio=0.0,
            total_trades=0,
            avg_trade_pnl_pct=0.0,
            profit_factor=0.0,
            bars_tested=len(bars),
        )

    wins = [t for t in trades if t.pnl_pct > 0]
    losses = [t for t in trades if t.pnl_pct <= 0]
    win_rate = (len(wins) / total_trades) * 100

    # Compounded return
    equity = 1.0
    peak = 1.0
    max_dd = 0.0
    for t in trades:
        equity *= (1 + t.pnl_pct / 100)
        if equity > peak:
            peak = equity
        dd = (peak - equity) / peak * 100
        if dd > max_dd:
            max_dd = dd

    total_return = (equity - 1) * 100

    # Average trade P&L
    avg_pnl = sum(t.pnl_pct for t in trades) / total_trades

    # Profit factor
    gross_profit = sum(t.pnl_pct for t in wins) if wins else 0
    gross_loss = abs(sum(t.pnl_pct for t in losses)) if losses else 0.001
    profit_factor = gross_profit / gross_loss if gross_loss > 0 else gross_profit

    # Sharpe ratio (annualized, assuming ~252 trading days)
    pnl_list = [t.pnl_pct for t in trades]
    mean_pnl = avg_pnl
    if len(pnl_list) > 1:
        variance = sum((p - mean_pnl) ** 2 for p in pnl_list) / (len(pnl_list) - 1)
        std_pnl = math.sqrt(variance) if variance > 0 else 0.001
    else:
        std_pnl = 0.001
    sharpe = (mean_pnl / std_pnl) * math.sqrt(min(252, total_trades)) if std_pnl > 0 else 0

    return BacktestResult(
        strategy_name=f"{strategy.name}({strategy.params})",
        ticker=ticker,
        trades=trades,
        total_return_pct=round(total_return, 2),
        win_rate=round(win_rate, 1),
        max_drawdown_pct=round(max_dd, 2),
        sharpe_ratio=round(sharpe, 2),
        total_trades=total_trades,
        avg_trade_pnl_pct=round(avg_pnl, 2),
        profit_factor=round(profit_factor, 2),
        bars_tested=len(bars),
    )


async def run_full_backtest(
    alpaca_client,
    tickers: list[str],
    strategies: list[Strategy] | None = None,
    lookback_days: int = 252,
) -> list[BacktestResult]:
    """
    Backtest all strategies on all tickers using Alpaca historical data.

    Returns a list of BacktestResult sorted by Sharpe ratio (best first).
    """
    if strategies is None:
        strategies = get_all_strategies()

    results: list[BacktestResult] = []

    for ticker in tickers:
        raw_bars = await alpaca_client.get_bars(ticker, timeframe="1Day", limit=lookback_days)
        if not raw_bars:
            log.warning("No data for %s — skipping", ticker)
            continue

        bars = parse_bars(raw_bars)
        if len(bars) < 60:
            log.warning("Only %d bars for %s — skipping (need 60+)", len(bars), ticker)
            continue

        for strategy in strategies:
            try:
                result = backtest_strategy(strategy, bars, ticker)
                results.append(result)
            except Exception as e:
                log.error("Backtest failed: %s on %s — %s", strategy.name, ticker, e)

    # Sort by Sharpe ratio descending
    results.sort(key=lambda r: r.sharpe_ratio, reverse=True)
    return results


# ── Engine State ──


@dataclass
class EngineState:
    """Current state of the trading engine."""
    active: bool = False
    selected_strategy: str | None = None
    selected_ticker: str | None = None
    last_backtest_at: str | None = None
    last_signal: TradeSignal | None = None
    backtest_results: list[BacktestResult] = field(default_factory=list)
    ai_recommendation: str | None = None
    paper_only: bool = True

    def to_dict(self) -> dict:
        return {
            "active": self.active,
            "selected_strategy": self.selected_strategy,
            "selected_ticker": self.selected_ticker,
            "last_backtest_at": self.last_backtest_at,
            "last_signal": {
                "ticker": self.last_signal.ticker,
                "side": self.last_signal.side.value,
                "price": self.last_signal.price,
                "timestamp": self.last_signal.timestamp,
                "strategy": self.last_signal.strategy,
                "confidence": self.last_signal.confidence,
                "reason": self.last_signal.reason,
            } if self.last_signal else None,
            "backtest_results_count": len(self.backtest_results),
            "top_results": [r.to_summary() for r in self.backtest_results[:10]],
            "ai_recommendation": self.ai_recommendation,
            "paper_only": self.paper_only,
        }


# Module-level engine state (singleton)
_engine_state = EngineState()


def get_engine_state() -> EngineState:
    return _engine_state


def reset_engine_state() -> None:
    global _engine_state
    _engine_state = EngineState()
